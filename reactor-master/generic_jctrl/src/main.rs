//! Dummy Ping Pong Service (L2) built on top of Tensile core (L1)
//! Specification:-
//!    Num Actors:- 2
//!    Common behaviour:- Responds to Ping/Pong Message with a Pong/Ping Message
//!    Special Behaviour:- Actor 1 sends Ping Message at the start
//!
//! Can we prove that Actor 1 will never recieve Ping, and Actor 2 will never recieve Pong?
//! Can we write the specification formally and generate the actor code and
//! prove properties of the system generated by the spec?

use clap::{Parser, command};
use reactor_jobm::JobController;
use reactor_jobm::placement::{ChaosMap, LogicalOp, ManualPlacementManager, NodeInfo, PhysicalOp};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use tokio::signal;

#[derive(Debug, Deserialize, PartialEq)]
pub struct JobManifest {
    pub nodes: Vec<NodeInfo>,
    pub ops: Vec<LogicalOp>,
    pub global_chaos: Option<ChaosMap>,
    pub placement: HashMap<String, Vec<PhysicalOp>>,
}

#[derive(Parser)]
#[command(name = "Job Controller", about = "Run reactor Job controller")]
pub struct Cli {
    pub job_manifest: PathBuf,
}

#[tokio::main]
async fn main() {
    let cli = Cli::parse();
    let contents = fs::read_to_string(cli.job_manifest).expect("File doesn't exist");
    let job_manifest: JobManifest = toml::from_str(&contents).expect("Toml Parse error");

    let ops = job_manifest.ops;
    let pm = ManualPlacementManager::new(job_manifest.placement, job_manifest.global_chaos);
    let mut jc = JobController::new(pm);

    for node in job_manifest.nodes {
        jc.register_node(&node.name, node.hostname.leak(), node.port);
    }

    jc.start_job(ops).await;
    jc.chaos_scheduler().await;
    let _ = signal::ctrl_c().await;
    jc.stop_job().await;
}

#[cfg(test)]
mod tests {
    use super::*;
    use reactor_jobm::placement::{
        CrashOp, Factor, MsgDelayOp, MsgDuplicationOp, MsgLossOp, Probability,
    };
    use serde_json::json;
    use std::collections::HashMap;

    #[test]
    fn test_manual_placement_manager_parse() {
        let toml_data = r#"
[[ops]]
name = "pinger"
lib_name = "ping_pong_actor"

[[ops]]
name = "ponger"
lib_name = "ping_pong_actor"

[[nodes]]
name = "node1"
hostname = "0.0.0.0"
port = 3000

[placement]
  [[placement.pinger]]
  nodename = "node1"
  actor_name = "pinger"
  other = "ponger"
  chaos.crash = { crash_ms = 10000 }
  chaos.msg_loss = { start_ms = 1000, probability = 0.1 }
  chaos.msg_duplication = { start_ms = 2000, probability = 0.1, factor = 2 }
  chaos.msg_delay = { start_ms = 3000, delay_range_ms = [100,200], senders = ["ponger"] }


  [[placement.ponger]]
  nodename = "node1"
  actor_name = "ponger"
  replicas = 3
  connection = { hashed = ["addr1", "addr2"] }
  op_args = { height = 1080, width = 1920, source = { type = "rtsp", url = "rtsp://example.com/stream" } }
"#;

        let parsed: JobManifest = toml::from_str(toml_data).expect("Failed to parse");

        let expected = JobManifest {
            ops: vec![
                LogicalOp {
                    name: "pinger".into(),
                    lib_name: "ping_pong_actor".into(),
                },
                LogicalOp {
                    name: "ponger".into(),
                    lib_name: "ping_pong_actor".into(),
                },
            ],
            global_chaos: None,
            placement: HashMap::from([
                (
                    "pinger".into(),
                    vec![PhysicalOp {
                        nodename: "node1".into(),
                        actor_name: "pinger".into(),
                        payload: HashMap::from([("other".to_string(), json!("ponger"))]),
                        replicas: None,
                        chaos: Some(ChaosMap {
                            crash: Some(CrashOp {
                                crash_ms: Some(10000),
                                restart_ms: None,
                            }),
                            msg_loss: Some(MsgLossOp {
                                start_ms: Some(1000),
                                probability: Probability(0.1),
                                stop_ms: None,
                            }),
                            msg_duplication: Some(MsgDuplicationOp {
                                start_ms: Some(2000),
                                probability: Probability(0.1),
                                factor: Factor(2),
                                stop_ms: None,
                            }),
                            msg_delay: Some(MsgDelayOp {
                                start_ms: Some(3000),
                                stop_ms: None,
                                delay_range_ms: (100, 200),
                                senders: vec!["ponger".into()],
                            }),
                        }),
                    }],
                ),
                (
                    "ponger".into(),
                    vec![PhysicalOp {
                        nodename: "node1".into(),
                        actor_name: "ponger".into(),
                        payload: HashMap::from([
                            (
                                "connection".to_string(),
                                json!({"hashed": ["addr1", "addr2"]}),
                            ),
                            (
                                "op_args".to_string(),
                                json!( {
                                    "height": 1080,
                                    "width":  1920,
                                    "source": { "type": "rtsp", "url": "rtsp://example.com/stream" }
                                } ),
                            ),
                        ]),
                        replicas: Some(3),
                        chaos: None,
                    }],
                ),
            ]),
            nodes: vec![NodeInfo {
                name: "node1".to_string(),
                hostname: "0.0.0.0".to_string(),
                port: 3000,
            }],
        };

        assert_eq!(parsed, expected);
        let pm = ManualPlacementManager::new(parsed.placement, parsed.global_chaos);

        let pinger_list = pm.map.get("pinger").unwrap();
        assert_eq!(pinger_list.len(), 1);
        assert_eq!(pinger_list[0].actor_name, "pinger");

        let ponger_list = pm.map.get("ponger").unwrap();
        assert_eq!(ponger_list.len(), 3);
        assert_eq!(
            ponger_list
                .iter()
                .map(|p| p.actor_name.as_str())
                .collect::<Vec<_>>(),
            vec!["ponger1", "ponger2", "ponger3"]
        );
        assert!(ponger_list.iter().all(|p| p.nodename == "node1"));
    }
}
